testing

+ should reveal how to use the thing to accomplish a goal
    - easy to read, easy to understand, easy to modify
+ should serve as documentation for consumers of the module under test
    - only a subset of the tests may be relevant (ignore path testing)
    - e.g., "given that I want to do this, how do I do it?"
+ should be crazy easy to write
    - friction points:
        - setting up testing environment
        - creating a test
        - generating data/stubbing the environment
            => in terms of Vue components:
                = props, slots, child components, $store, $router, API calls
                = more? (will discover as I write tests)
+ should be crazy easy to run
    - selecting only certain suites/tests
    - running on change
        => compile time is the big issue
+ should be crazy easy to interpret
    - minimal, informative reporters integrated with editor
    - easy-to-build custom reporters
    - interactive stack traces
    - I'm imagining something between a debugger and println
        => inline evaluation (given a frame of reference, show values in the code itself; capture a set of values over time)
+ should be crazy easy to interact with
    - jump to debugger with a REPL at any point
        => should have "back up" function


What is the ideal flow?
There can't be a single flow, because we write different tests for different reasons.
Focus on building components for now.


===========
VUE TESTING
===========

Tests will run in the browser (for now).
Tests might fuck up/be fucked up by the global scope, but I'll deal with that later.
describe/it syntax is pretty good.
    - issue: how do I pull a component out for each test?
        + can't do beforeEach, because setup might happen in-test
        + could rely on a cmp variable in the describe block,
            then watch it. Every time it gets assigned to, we match the assignment to a test.
How will I handle results? Don't know yet. Ideally I'll have an API that throws events that I can hook up to Vue components.
will need a good way to stub the environment (and share stubbing with stories)
    - ideally, would build itself as much as possible
        + run a test, figure out what it relies on, add a stub for it
        + API call data = fixtures generated from endpoint tests (common practice)
        + grab values from acceptance tests/live environment?


=======
THE MAP
=======

1) using describe/it syntax, run a single test in the browser unmounted and report results on-page + make available as data structure in console
2) optionally mount the test
3) report results in expanded/succinct ways
    - rather than gathering all the data myself, it seems best to use mochawesome
    - I'll just ignore the report generator and write my own with Vue components

Now that I have a basic test runner, I need to integrate it into the editor.

Given a file (.vue/.js), I should be able to find the unit tests or prompt to bootstrap them if not found.
    - for now, assume tests/unit/{{ matching path to current file under src directory }}
    - bootstrapping is simple. import assertions, component, mount, then drop cmp name in describe block.
There should be a shortcut for adding new tests + marking them async/using done callback
    - simple. ask for a name, then drop cursor inside the function. use shortcuts to trigger async/done.
Once there are tests in the file, it should be easy to select and run them.
    - I imagine a small pane that expands from the bottom of the screen.
        + when folded, it indicates the number of tests that passed, the overall time, and whether it is running
        + when open, it lists all tests, shows which ones are running, and give keyboard access to turning a test on/off
        + creating new tests can be done in here, too
    - there'll need to be a global shortcut for running the selected tests
        + if "ctrl+r" toggles the pane, then "ctrl+shift+r" should run it
    - the pane can report pass/fail in-context, but detailed diffs will require more screenspace (a modal? a full pane?)
Then I can worry about stories
    - component factories: functions that return a component mounted by vue-test-utils
        + actually, they'll have to use my intercepted version, but that's a small detail
        + then I can use the factory in tests, too.
        + if I mount a component directly in a test, I should be able to refactor it easily into a factory
    - the context should be interactive (e.g., editing props on the fly, stubbing/passing through network requests)

I'll make my way back to expectThat some day. Maybe this week, maybe not.
Eventually I'll need to write my own debug pane, since the official one kinda sucks.